{"ast":null,"code":"import { useRef, useState, useEffect } from 'react';\nimport { clamp } from '../utils/clamp/clamp.js';\n\nconst clampUseMovePosition = position => ({\n  x: clamp(position.x, 0, 1),\n  y: clamp(position.y, 0, 1)\n});\n\nfunction useMove(onChange, handlers, dir = \"ltr\") {\n  const ref = useRef();\n  const mounted = useRef(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n  useEffect(() => {\n    const onScrub = ({\n      x,\n      y\n    }) => {\n      cancelAnimationFrame(frame.current);\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && ref.current) {\n          ref.current.style.userSelect = \"none\";\n          const rect = ref.current.getBoundingClientRect();\n\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n\n            onChange({\n              x: dir === \"ltr\" ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1)\n            });\n          }\n        }\n      });\n    };\n\n    const bindEvents = () => {\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mouseup\", stopScrubbing);\n      document.addEventListener(\"touchmove\", onTouchMove);\n      document.addEventListener(\"touchend\", stopScrubbing);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseup\", stopScrubbing);\n      document.removeEventListener(\"touchmove\", onTouchMove);\n      document.removeEventListener(\"touchend\", stopScrubbing);\n    };\n\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof (handlers == null ? void 0 : handlers.onScrubStart) === \"function\" && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof (handlers == null ? void 0 : handlers.onScrubEnd) === \"function\" && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n\n    const onMouseDown = event => {\n      startScrubbing();\n      onMouseMove(event);\n    };\n\n    const onMouseMove = event => onScrub({\n      x: event.clientX,\n      y: event.clientY\n    });\n\n    const onTouchStart = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      startScrubbing();\n      onTouchMove(event);\n    };\n\n    const onTouchMove = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      onScrub({\n        x: event.changedTouches[0].clientX,\n        y: event.changedTouches[0].clientY\n      });\n    };\n\n    ref.current.addEventListener(\"mousedown\", onMouseDown);\n    ref.current.addEventListener(\"touchstart\", onTouchStart, {\n      passive: false\n    });\n    return () => {\n      if (ref.current) {\n        ref.current.removeEventListener(\"mousedown\", onMouseDown);\n        ref.current.removeEventListener(\"touchstart\", onTouchStart);\n      }\n    };\n  }, [dir, onChange]);\n  return {\n    ref,\n    active\n  };\n}\n\nexport { clampUseMovePosition, useMove };","map":{"version":3,"sources":["../../src/use-move/use-move.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { useEffect, useState, useRef } from 'react';\nimport { clamp } from '../utils';\n\nexport interface UseMovePosition {\n  x: number;\n  y: number;\n}\n\nexport const clampUseMovePosition = (position: UseMovePosition) => ({\n  x: clamp(position.x, 0, 1),\n  y: clamp(position.y, 0, 1),\n});\n\ninterface useMoveHandlers {\n  onScrubStart?(): void;\n  onScrubEnd?(): void;\n}\n\nexport function useMove<T extends HTMLElement = HTMLDivElement>(\n  onChange: (value: UseMovePosition) => void,\n  handlers?: useMoveHandlers,\n  dir: 'ltr' | 'rtl' = 'ltr'\n) {\n  const ref = useRef<T>();\n  const mounted = useRef<boolean>(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n\n  useEffect(() => {\n    const onScrub = ({ x, y }: UseMovePosition) => {\n      cancelAnimationFrame(frame.current);\n\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && ref.current) {\n          ref.current.style.userSelect = 'none';\n          const rect = ref.current.getBoundingClientRect();\n\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n            onChange({\n              x: dir === 'ltr' ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1),\n            });\n          }\n        }\n      });\n    };\n\n    const bindEvents = () => {\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', stopScrubbing);\n      document.addEventListener('touchmove', onTouchMove);\n      document.addEventListener('touchend', stopScrubbing);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', stopScrubbing);\n      document.removeEventListener('touchmove', onTouchMove);\n      document.removeEventListener('touchend', stopScrubbing);\n    };\n\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof handlers?.onScrubStart === 'function' && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof handlers?.onScrubEnd === 'function' && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n\n    const onMouseDown = (event: MouseEvent) => {\n      startScrubbing();\n      onMouseMove(event);\n    };\n\n    const onMouseMove = (event: MouseEvent) => onScrub({ x: event.clientX, y: event.clientY });\n\n    const onTouchStart = (event: TouchEvent) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      startScrubbing();\n      onTouchMove(event);\n    };\n\n    const onTouchMove = (event: TouchEvent) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });\n    };\n\n    ref.current.addEventListener('mousedown', onMouseDown);\n    ref.current.addEventListener('touchstart', onTouchStart, { passive: false });\n\n    return () => {\n      if (ref.current) {\n        ref.current.removeEventListener('mousedown', onMouseDown);\n        ref.current.removeEventListener('touchstart', onTouchStart);\n      }\n    };\n  }, [dir, onChange]);\n\n  return { ref, active };\n}\n"]},"metadata":{},"sourceType":"module"}